name: Build, Push to Private Registry and Deploy with Helm

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: "127.0.0.1:30500"
  IMAGE_NAME: "django-app"
  K8S_NAMESPACE: "django-app"
  HELM_RELEASE: "django-app"

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run tests
        run: |
          python manage.py test

  build-and-push:
    needs: test
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4

      - name: Build and Push Native
        run: |
          docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest .
          docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} .
          
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

  deploy-with-helm:
    needs: build-and-push
    runs-on: self-hosted
    if: github.ref == 'refs/heads/main'

    steps:
      - uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: "3.12.0"

      - name: Set up Kubeconfig Secret
        uses: azure/k8s-set-context@v3
        with:
          kubeconfig: ${{ secrets.KUBECONFIG }}

      - name: Deploy with Helm
        run: |
          helm upgrade --install ${{ env.HELM_RELEASE }} ./django-app-chart \
            --namespace ${{ env.K8S_NAMESPACE }} \
            --create-namespace \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set image.tag=latest \
            --set app.replicas=3 \
            --wait \
            --timeout 300s
          
          helm list -n ${{ env.K8S_NAMESPACE }}
          kubectl get pods,svc -n ${{ env.K8S_NAMESPACE }}

      - name: Run database migrations
        run: |
          POD_NAME=$(kubectl get pods -n ${{ env.K8S_NAMESPACE }} --field-selector=status.phase=Running --no-headers -o custom-columns=":metadata.name" | head -n 1 | xargs)
          
          if [ -z "$POD_NAME" ]; then
             echo "❌ Error: No running pods found"
             exit 1
          fi
          
          echo "✅ Migrating on pod: $POD_NAME"
          
          kubectl exec -n ${{ env.K8S_NAMESPACE }} $POD_NAME -- python manage.py migrate
          kubectl exec -n ${{ env.K8S_NAMESPACE }} $POD_NAME -- python manage.py collectstatic --noinput

  smoke-test:
    needs: deploy-with-helm
    runs-on: self-hosted

    steps:
      - name: Check application health (Internal Check)
        run: |
          # 1. Находим имя пода
          POD_NAME=$(kubectl get pods -n ${{ env.K8S_NAMESPACE }} --field-selector=status.phase=Running --no-headers -o custom-columns=":metadata.name" | head -n 1 | xargs)

          if [ -z "$POD_NAME" ]; then
             echo "❌ Error: No running pods found for smoke test!"
             exit 1
          fi

          echo "✅ Testing inside pod: $POD_NAME"

          # 2. Создаем Python скрипт. Обрати внимание на отступы - они выровнены внутри run блока.
          cat << 'EOF' > check_health.py
          import urllib.request
          import sys

          endpoints = ['http://127.0.0.1:8000/health/', 'http://127.0.0.1:8000/metrics/']
          errors = 0

          print("Starting connectivity test...")
          for url in endpoints:
              try:
                  # Таймаут 5 секунд
                  resp = urllib.request.urlopen(url, timeout=5)
                  code = resp.getcode()
                  if code == 200:
                      print(f"✅ OK: {url} -> {code}")
                  else:
                      print(f"⚠️ Warning: {url} -> {code}")
              except Exception as e:
                  print(f"❌ Failed: {url} -> {e}")
                  # Раскомментируй строку ниже, если хочешь, чтобы пайплайн падал при недоступности URL
                  # errors += 1

          if errors > 0:
              sys.exit(1)
          EOF

          # 3. Запускаем скрипт внутри пода
          kubectl exec -i -n ${{ env.K8S_NAMESPACE }} $POD_NAME -- python < check_health.py
          
          # Удаляем временный файл
          rm check_health.py
